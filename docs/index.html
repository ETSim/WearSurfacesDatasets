<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Enhanced WebGPU Material Viewer</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
      body {
        margin: 0;
        padding: 0;
        background-color: #202020;
        font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        overflow: hidden;
      }
      canvas {
        display: block;
        width: 100vw;
        height: 100vh;
        cursor: grab;
      }
      canvas:active { cursor: grabbing; }

      .controls {
        position: absolute;
        top: 10px;
        left: 10px;
        color: white;
        background: rgba(0,0,0,0.9);
        padding: 20px;
        border-radius: 16px;
        max-height: 90vh;
        overflow-y: auto;
        width: 340px;
        backdrop-filter: blur(20px);
        border: 1px solid rgba(255,255,255,0.15);
        box-shadow: 0 20px 40px rgba(0,0,0,0.4);
      }

      .control-section {
        margin-bottom: 24px;
        border-bottom: 1px solid #333;
        padding-bottom: 18px;
      }
      .control-section:last-child { border-bottom: none; }
      .control-section h3 {
        margin: 0 0 16px 0;
        color: #fff;
        font-size: 16px;
        font-weight: 600;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      label {
        display: block;
        margin-bottom: 12px;
        font-size: 14px;
        color: #ddd;
        font-weight: 500;
      }

      input[type="range"] {
        width: 100%;
        margin: 8px 0;
        height: 8px;
        border-radius: 4px;
        background: #333;
        outline: none;
        -webkit-appearance: none;
        transition: all 0.3s ease;
      }
      input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: linear-gradient(135deg, #4CAF50, #45a049);
        cursor: pointer;
        box-shadow: 0 2px 8px rgba(76, 175, 80, 0.3);
        transition: all 0.3s ease;
      }
      input[type="range"]::-webkit-slider-thumb:hover {
        transform: scale(1.1);
        box-shadow: 0 4px 12px rgba(76, 175, 80, 0.5);
      }

      input[type="checkbox"] {
        width: 18px;
        height: 18px;
        margin-right: 10px;
        accent-color: #4CAF50;
        cursor: pointer;
      }

      select {
        width: 100%;
        margin-bottom: 12px;
        background: #333;
        color: white;
        border: 1px solid #555;
        padding: 10px;
        border-radius: 8px;
        font-size: 14px;
        cursor: pointer;
        transition: all 0.3s ease;
      }
      select:hover {
        border-color: #4CAF50;
      }

      button {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        padding: 12px 18px;
        margin: 6px;
        border-radius: 10px;
        cursor: pointer;
        font-size: 14px;
        font-weight: 600;
        transition: all 0.3s ease;
        box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
      }
      button:hover {
        transform: translateY(-3px);
        box-shadow: 0 8px 25px rgba(102, 126, 234, 0.5);
      }
      button:active { transform: translateY(-1px); }

      .button-group {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        margin-top: 10px;
      }

      .mode-button {
        flex: 1;
        min-width: 140px;
      }
      .mode-button.active {
        background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
        box-shadow: 0 4px 15px rgba(76, 175, 80, 0.4);
      }

      .download-section {
        display: flex;
        gap: 10px;
        margin-top: 12px;
      }
      .download-button {
        flex: 1;
        font-size: 12px;
        padding: 8px 12px;
      }

      .file-input-container {
        position: relative;
        overflow: hidden;
        display: inline-block;
        width: 100%;
        margin-bottom: 12px;
      }

      .file-input {
        position: absolute;
        left: -9999px;
      }

      .file-input-label {
        display: block;
        padding: 14px;
        background: linear-gradient(135deg, #FF6B6B 0%, #ee5a52 100%);
        color: white;
        text-align: center;
        border-radius: 10px;
        cursor: pointer;
        transition: all 0.3s ease;
        font-weight: 600;
        box-shadow: 0 4px 15px rgba(255, 107, 107, 0.3);
      }

      .file-input-label:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 25px rgba(255, 107, 107, 0.5);
      }

      .texture-info {
        background: rgba(255,255,255,0.08);
        padding: 14px;
        border-radius: 10px;
        margin: 14px 0;
        font-size: 13px;
        color: #bbb;
        border: 1px solid rgba(255,255,255,0.1);
      }

      .texture-info .loaded {
        color: #4CAF50;
        font-weight: 600;
      }

      .texture-info .missing {
        color: #ff6b6b;
      }

      .loading-indicator {
        display: none;
        text-align: center;
        padding: 20px;
        color: #4CAF50;
        font-weight: 600;
      }

      .loading-indicator.active {
        display: block;
      }

      .status-message {
        padding: 12px;
        border-radius: 8px;
        margin: 12px 0;
        font-size: 13px;
        font-weight: 500;
        display: none;
      }

      .status-message.success {
        background: rgba(76, 175, 80, 0.2);
        color: #4CAF50;
        border: 1px solid rgba(76, 175, 80, 0.4);
      }

      .status-message.error {
        background: rgba(255, 107, 107, 0.2);
        color: #ff6b6b;
        border: 1px solid rgba(255, 107, 107, 0.4);
      }

      .range-value {
        display: inline-block;
        min-width: 50px;
        text-align: right;
        font-weight: 600;
        color: #4CAF50;
        font-size: 13px;
      }

      .intensity-controls {
        background: rgba(255,255,255,0.05);
        padding: 12px;
        border-radius: 8px;
        margin: 10px 0;
        border: 1px solid rgba(255,255,255,0.1);
      }

      .zoom-controls {
        display: flex;
        align-items: center;
        gap: 10px;
        margin: 10px 0;
      }

      .zoom-button {
        width: 36px;
        height: 36px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 18px;
        font-weight: bold;
        margin: 0;
        padding: 0;
      }

      .shading-model-selector {
        margin: 10px 0;
      }
    </style>
  </head>
  <body>
    <canvas width="800" height="600"></canvas>
    <div class="controls">
      <div class="control-section">
        <h3>üé® Material Loading</h3>
        <div class="file-input-container">
          <input type="file" id="textureFolder" class="file-input" multiple accept="image/*" webkitdirectory>
          <label for="textureFolder" class="file-input-label">
            üìÅ Load Material Folder
          </label>
        </div>

        <div class="file-input-container">
          <input type="file" id="individualTextures" class="file-input" multiple accept="image/*">
          <label for="individualTextures" class="file-input-label">
            üñºÔ∏è Load Individual Textures
          </label>
        </div>

        <div id="loadingIndicator" class="loading-indicator">
          <div>Loading textures...</div>
        </div>

        <div id="statusMessage" class="status-message"></div>

        <div id="textureInfo" class="texture-info">
          <div>Current Material: <span id="currentMaterial">Default Material</span></div>
          <div class="texture-status">
            <div>Base Color: <span id="baseColorStatus" class="loaded">‚úì</span></div>
            <div>Normal: <span id="normalStatus" class="loaded">‚úì</span></div>
            <div>Roughness: <span id="roughnessStatus" class="loaded">‚úì</span></div>
            <div>Metallic: <span id="metallicStatus" class="loaded">‚úì</span></div>
            <div>AO: <span id="aoStatus" class="missing">‚úó</span></div>
            <div>Displacement: <span id="displacementStatus" class="missing">‚úó</span></div>
            <div>Emissive: <span id="emissiveStatus" class="missing">‚úó</span></div>
            <div>Curvature: <span id="curvatureStatus" class="missing">‚úó</span></div>
            <div>Bump: <span id="bumpStatus" class="missing">‚úó</span></div>
          </div>
        </div>
      </div>

      <div class="control-section">
        <h3>üéØ Display Mode</h3>
        <div class="button-group">
          <button id="mode2D" class="mode-button active">2D Mode</button>
          <button id="mode3D" class="mode-button">3D Mode</button>
        </div>
      </div>

      <div id="mapping-controls" class="control-section">
        <h3>‚öôÔ∏è PBR Mapping</h3>
        <label><input type="checkbox" id="baseColorMapping" checked> Base Color</label>
        
        <label><input type="checkbox" id="normalMapping" checked> Normal Mapping</label>
        <div class="intensity-controls">
          <label>
            Normal Intensity:
            <input type="range" id="normalMapIntensity" min="0" max="3" value="1" step="0.01">
            <span id="normalMapIntensityValue" class="range-value">1.00</span>
          </label>
        </div>
        
        <label><input type="checkbox" id="roughnessMapping" checked> Roughness</label>
        <label><input type="checkbox" id="metallicMapping" checked> Metallic</label>
        <label><input type="checkbox" id="aoMapping"> Ambient Occlusion</label>
        
        <label><input type="checkbox" id="displacementMapping"> Displacement</label>
        <div class="intensity-controls">
          <label>
            Displacement Scale:
            <input type="range" id="displacementScale" min="0" max="0.5" value="0.1" step="0.001">
            <span id="displacementScaleValue" class="range-value">0.10</span>
          </label>
        </div>
        
        <label><input type="checkbox" id="emissiveMapping"> Emissive</label>
        
        <label><input type="checkbox" id="curvatureMapping"> Curvature</label>
        <div class="intensity-controls">
          <label>
            Curvature Intensity:
            <input type="range" id="curvatureIntensity" min="0" max="2" value="1" step="0.01">
            <span id="curvatureIntensityValue" class="range-value">1.00</span>
          </label>
        </div>
        
        <label><input type="checkbox" id="bumpMapping"> Bump Mapping</label>
        <div class="intensity-controls">
          <label>
            Bump Intensity:
            <input type="range" id="bumpIntensity" min="0" max="2" value="1" step="0.01">
            <span id="bumpIntensityValue" class="range-value">1.00</span>
          </label>
        </div>
      </div>

      <div id="3d-controls" class="control-section">
        <h3>üé≤ 3D Controls</h3>
        <label>
          Model:
          <select id="modelSelect">
            <option value="plane">Plane</option>
            <option value="cube">Cube</option>
            <option value="sphere">Sphere</option>
            <option value="cylinder">Cylinder</option>
            <option value="teapot">Teapot</option>
          </select>
        </label>
        
        <div class="shading-model-selector">
          <label>
            Shading Model:
            <select id="shadingModel">
              <option value="blinn-phong">Blinn-Phong</option>
              <option value="ggx">GGX (PBR)</option>
            </select>
          </label>
        </div>
        
        <button id="toggleAutoRotate">Stop Rotation</button>
        <div class="button-group">
          <button id="resetView">üîÑ Reset View</button>
        </div>
        
        <div class="zoom-controls">
          <button id="zoomOut" class="zoom-button">‚àí</button>
          <label style="flex: 1; margin: 0;">
            Zoom:
            <input type="range" id="zoomLevel" min="0.5" max="15" value="3" step="0.1">
            <span id="zoomLevelValue" class="range-value">3.0</span>
          </label>
          <button id="zoomIn" class="zoom-button">+</button>
        </div>
      </div>

      <div id="light-controls" class="control-section">
        <h3>üí° Lighting</h3>
        <label>
          Light X: <span id="lightPosXValue" class="range-value">2.0</span>
          <input type="range" id="lightPosX" min="-10" max="10" value="2" step="0.1">
        </label>
        <label>
          Light Y: <span id="lightPosYValue" class="range-value">2.0</span>
          <input type="range" id="lightPosY" min="-10" max="10" value="2" step="0.1">
        </label>
        <label>
          Light Z: <span id="lightPosZValue" class="range-value">2.0</span>
          <input type="range" id="lightPosZ" min="-10" max="10" value="2" step="0.1">
        </label>
        <label>
          Intensity: <span id="lightIntensityValue" class="range-value">4.0</span>
          <input type="range" id="lightIntensity" min="0" max="20" value="4" step="0.1">
        </label>
        <label>
          <input type="checkbox" id="enableDirectionalLight" checked> Directional Light
        </label>
        <label>
          <input type="checkbox" id="enablePointLight"> Point Light
        </label>
      </div>

      <div id="download-controls" class="control-section">
        <h3>üíæ Export</h3>
        <div class="download-section">
          <button id="downloadPNG" class="download-button">PNG</button>
          <button id="downloadJPG" class="download-button">JPG</button>
          <button id="downloadTIFF" class="download-button">TIFF</button>
        </div>
        <button id="downloadAllMaps">üì¶ Download All Maps</button>
      </div>
    </div>

    <script type="module">
      class MaterialViewer {
        constructor() {
          this.canvas = document.querySelector("canvas");
          this.device = null;
          this.context = null;
          this.canvasFormat = null;
          this.pipeline = null;
          this.bindGroup = null;
          this.uniformBuffer = null;
          this.depthTexture = null;
          this.sampler = null;
          this.currentGeometry = null;
          this.vertexBuffer = null;
          this.indexBuffer = null;

          this.state = {
            mode: "2D",
            model: "plane",
            autoRotate: true,
            rotation: { x: 0, y: 0 },
            dragState: { dragging: false, lastX: 0, lastY: 0 },
            lightPos: { x: 2, y: 2, z: 2 },
            lightIntensity: 4,
            displacementScale: 0.1,
            normalMapIntensity: 1.0,
            curvatureIntensity: 1.0,
            bumpIntensity: 1.0,
            zoomLevel: 3.0,
            shadingModel: "ggx", // "blinn-phong" or "ggx"
            enableDirectionalLight: true,
            enablePointLight: false,
            maps: {
              baseColor: true,
              normal: true,
              roughness: true,
              metallic: true,
              ao: false,
              displacement: false,
              emissive: false,
              curvature: false,
              bump: false
            }
          };

          this.textures = {
            baseColor: null,
            normal: null,
            roughness: null,
            metallic: null,
            ao: null,
            displacement: null,
            emissive: null,
            curvature: null,
            bump: null
          };

          this.textureStatus = {
            baseColor: false,
            normal: false,
            roughness: false,
            metallic: false,
            ao: false,
            displacement: false,
            emissive: false,
            curvature: false,
            bump: false
          };

          this.currentMaterialName = "Default Material";
          this.startTime = performance.now();
          this.lastTime = this.startTime;
        }

        async init() {
          if (!navigator.gpu) {
            this.showError("WebGPU is not supported on this browser. Please try Chrome 113+ or Edge 113+.");
            throw new Error("WebGPU not supported");
          }

          const adapter = await navigator.gpu.requestAdapter({
            powerPreference: "high-performance"
          });
          if (!adapter) {
            this.showError("No appropriate GPUAdapter found.");
            throw new Error("No appropriate GPUAdapter found.");
          }

          this.device = await adapter.requestDevice();
          console.log("WebGPU device initialized");

          this.context = this.canvas.getContext("webgpu");
          this.canvasFormat = navigator.gpu.getPreferredCanvasFormat();
          this.context.configure({
            device: this.device,
            format: this.canvasFormat,
            alphaMode: "premultiplied",
          });

          this.resizeCanvas();
          window.addEventListener("resize", () => this.resizeCanvas());

          await this.initializeResources();
          this.setupEventListeners();
          await this.loadDefaultTextures();
          this.render();

          this.showSuccess("Material Viewer initialized successfully!");
        }

        resizeCanvas() {
          this.canvas.width = window.innerWidth;
          this.canvas.height = window.innerHeight;
          this.updateDepthTexture();
        }

        async initializeResources() {
          this.sampler = this.device.createSampler({
            magFilter: "linear",
            minFilter: "linear",
            mipmapFilter: "linear",
            addressModeU: "repeat",
            addressModeV: "repeat",
          });

          const uniformBufferSize = 160 * 4;
          this.uniformBuffer = this.device.createBuffer({
            label: "Uniform Buffer",
            size: uniformBufferSize,
            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
          });

          await this.createPipeline();
          this.updateDepthTexture();
          this.updateGeometry();
        }

        async createPipeline() {
          const shaderCode = `
            struct VertexInput {
              @location(0) position: vec3f,
              @location(1) texCoord: vec2f,
              @location(2) normal: vec3f,
              @location(3) tangent: vec3f,
            };

            struct VertexOutput {
              @builtin(position) position: vec4f,
              @location(0) texCoord: vec2f,
              @location(1) tangentLightPos: vec3f,
              @location(2) tangentViewPos: vec3f,
              @location(3) tangentFragPos: vec3f,
              @location(4) worldPos: vec3f,
              @location(5) worldNormal: vec3f,
              @location(6) worldTangent: vec3f,
            };

            struct Uniforms {
              viewMatrix: mat4x4f,
              projMatrix: mat4x4f,
              modelMatrix: mat4x4f,
              normalMatrix: mat4x4f,
              viewPos: vec4f,
              lightPos: vec4f,
              lightColor: vec4f,
              useBaseColorMap: f32,
              useNormalMap: f32,
              useRoughnessMap: f32,
              useMetallicMap: f32,
              useAOMap: f32,
              useDisplacementMap: f32,
              useEmissiveMap: f32,
              useCurvatureMap: f32,
              useBumpMap: f32,
              displayMode: f32,
              normalMapIntensity: f32,
              curvatureIntensity: f32,
              bumpIntensity: f32,
              displacementScale: f32,
              shadingModel: f32,
              enableDirectionalLight: f32,
              enablePointLight: f32,
              time: f32,
            };

            @group(0) @binding(0) var texSampler: sampler;
            @group(0) @binding(1) var baseColorMap: texture_2d<f32>;
            @group(0) @binding(2) var normalMap: texture_2d<f32>;
            @group(0) @binding(3) var roughnessMap: texture_2d<f32>;
            @group(0) @binding(4) var metallicMap: texture_2d<f32>;
            @group(0) @binding(5) var aoMap: texture_2d<f32>;
            @group(0) @binding(6) var displacementMap: texture_2d<f32>;
            @group(0) @binding(7) var emissiveMap: texture_2d<f32>;
            @group(0) @binding(8) var curvatureMap: texture_2d<f32>;
            @group(0) @binding(9) var bumpMap: texture_2d<f32>;
            @group(0) @binding(10) var<uniform> uniforms: Uniforms;

            @vertex
            fn vertexMain(input: VertexInput) -> VertexOutput {
              var output: VertexOutput;

              let worldPos = (uniforms.modelMatrix * vec4f(input.position, 1.0)).xyz;
              output.worldPos = worldPos;
              output.position = uniforms.projMatrix * uniforms.viewMatrix * vec4f(worldPos, 1.0);
              output.texCoord = input.texCoord;

              let N = normalize((uniforms.normalMatrix * vec4f(input.normal, 0.0)).xyz);
              let T = normalize((uniforms.normalMatrix * vec4f(input.tangent, 0.0)).xyz);
              let B = normalize(cross(N, T));
              let TBN = mat3x3f(T, B, N);

              output.worldNormal = N;
              output.worldTangent = T;
              output.tangentFragPos = TBN * worldPos;
              output.tangentLightPos = TBN * uniforms.lightPos.xyz;
              output.tangentViewPos = TBN * uniforms.viewPos.xyz;

              return output;
            }

            fn perturbNormalFromBumpMap(originalNormal: vec3f, texCoord: vec2f, strength: f32) -> vec3f {
              let texSize = vec2f(textureDimensions(bumpMap));
              let pixelSize = 1.0 / texSize;

              let hC = textureSample(bumpMap, texSampler, texCoord).r;
              let hL = textureSample(bumpMap, texSampler, texCoord + vec2f(-pixelSize.x, 0.0)).r;
              let hR = textureSample(bumpMap, texSampler, texCoord + vec2f(pixelSize.x, 0.0)).r;
              let hB = textureSample(bumpMap, texSampler, texCoord + vec2f(0.0, pixelSize.y)).r;
              let hT = textureSample(bumpMap, texSampler, texCoord + vec2f(0.0, -pixelSize.y)).r;

              let dX = (hR - hL) * strength;
              let dY = (hT - hB) * strength;

              var newNormal = normalize(vec3f(dX, dY, 1.0));
              return mix(originalNormal, newNormal, strength);
            }

            fn DistributionGGX(N: vec3f, H: vec3f, roughness: f32) -> f32 {
              let a = roughness * roughness;
              let a2 = a * a;
              let NdotH = max(dot(N, H), 0.0);
              let NdotH2 = NdotH * NdotH;

              let num = a2;
              var denom = (NdotH2 * (a2 - 1.0) + 1.0);
              denom = 3.14159265359 * denom * denom;

              return num / denom;
            }

            fn GeometrySchlickGGX(NdotV: f32, roughness: f32) -> f32 {
              let r = (roughness + 1.0);
              let k = (r * r) / 8.0;

              let num = NdotV;
              let denom = NdotV * (1.0 - k) + k;

              return num / denom;
            }

            fn GeometrySmith(N: vec3f, V: vec3f, L: vec3f, roughness: f32) -> f32 {
              let NdotV = max(dot(N, V), 0.0);
              let NdotL = max(dot(N, L), 0.0);
              let ggx2 = GeometrySchlickGGX(NdotV, roughness);
              let ggx1 = GeometrySchlickGGX(NdotL, roughness);

              return ggx1 * ggx2;
            }

            fn fresnelSchlick(cosTheta: f32, F0: vec3f) -> vec3f {
              return F0 + (1.0 - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);
            }

            @fragment
            fn fragmentMain(input: VertexOutput) -> @location(0) vec4f {
              var texCoord = input.texCoord;

              // Displacement mapping
              if (uniforms.useDisplacementMap > 0.5 && uniforms.displayMode > 0.5) {
                let viewDir = normalize(input.tangentViewPos - input.tangentFragPos);
                let height = textureSample(displacementMap, texSampler, texCoord).r;
                let offset = viewDir.xy * height * uniforms.displacementScale;
                texCoord = texCoord - offset;
              }

              // Sample material properties
              var baseColor: vec3f;
              if (uniforms.useBaseColorMap > 0.5) {
                baseColor = textureSample(baseColorMap, texSampler, texCoord).rgb;
              } else {
                baseColor = vec3f(0.8, 0.8, 0.8);
              }

              var normal: vec3f;
              if (uniforms.useNormalMap > 0.5) {
                normal = textureSample(normalMap, texSampler, texCoord).rgb;
                normal = normalize(normal * 2.0 - 1.0);
                normal = mix(vec3f(0.0, 0.0, 1.0), normal, uniforms.normalMapIntensity);
              } else {
                normal = vec3f(0.0, 0.0, 1.0);
              }

              // Apply bump mapping
              if (uniforms.useBumpMap > 0.5) {
                normal = perturbNormalFromBumpMap(normal, texCoord, uniforms.bumpIntensity);
              }

              var roughness: f32;
              if (uniforms.useRoughnessMap > 0.5) {
                roughness = textureSample(roughnessMap, texSampler, texCoord).r;
              } else {
                roughness = 0.5;
              }
              roughness = max(roughness, 0.04);

              var metallic: f32;
              if (uniforms.useMetallicMap > 0.5) {
                metallic = textureSample(metallicMap, texSampler, texCoord).r;
              } else {
                metallic = 0.0;
              }

              var ao: f32;
              if (uniforms.useAOMap > 0.5) {
                ao = textureSample(aoMap, texSampler, texCoord).r;
              } else {
                ao = 1.0;
              }

              var emissive: vec3f;
              if (uniforms.useEmissiveMap > 0.5) {
                emissive = textureSample(emissiveMap, texSampler, texCoord).rgb;
              } else {
                emissive = vec3f(0.0);
              }

              // Apply curvature mapping
              if (uniforms.useCurvatureMap > 0.5) {
                let curvature = textureSample(curvatureMap, texSampler, texCoord).r;
                ao *= mix(1.0, curvature, uniforms.curvatureIntensity);
              }

              // 2D Mode
              if (uniforms.displayMode < 0.5) {
                return vec4f(baseColor, 1.0);
              }

              // 3D PBR rendering
              let lightColor = uniforms.lightColor.rgb;
              let lightPower = uniforms.lightColor.a;

              var N = normalize(input.worldNormal);
              let V = normalize(uniforms.viewPos.xyz - input.worldPos);
              let L = normalize(uniforms.lightPos.xyz - input.worldPos);
              let H = normalize(V + L);

              // Transform normal from tangent space to world space
              if (uniforms.useNormalMap > 0.5 || uniforms.useBumpMap > 0.5) {
                let T = normalize(input.worldTangent - dot(input.worldTangent, N) * N);
                let B = cross(N, T);
                let TBN = mat3x3f(T, B, N);
                N = normalize(TBN * normal);
              }

              let ambient = 0.03 * baseColor * ao;

              var finalColor: vec3f;

              if (uniforms.shadingModel < 0.5) {
                // Blinn-Phong shading
                let diff = max(dot(N, L), 0.0);
                let diffuse = diff * baseColor * lightColor * lightPower;

                let spec = pow(max(dot(N, H), 0.0), 32.0 / (roughness * roughness));
                var specularColor = vec3f(0.04);
                if (metallic > 0.5) {
                  specularColor = baseColor;
                }
                let specular = lightColor * spec * (1.0 - roughness) * specularColor;

                finalColor = ambient + diffuse + specular + emissive;
              } else {
                // GGX PBR shading
                let F0 = mix(vec3f(0.04), baseColor, metallic);

                let NDF = DistributionGGX(N, H, roughness);
                let G = GeometrySmith(N, V, L, roughness);
                let F = fresnelSchlick(max(dot(H, V), 0.0), F0);

                let kS = F;
                let kD = (vec3f(1.0) - kS) * (1.0 - metallic);

                let numerator = NDF * G * F;
                let denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.0001;
                let specular = numerator / denominator;

                let NdotL = max(dot(N, L), 0.0);
                let Lo = (kD * baseColor / 3.14159265359 + specular) * lightColor * NdotL * lightPower;

                finalColor = ambient + Lo + emissive;
              }

              // Tone mapping and gamma correction
              finalColor = finalColor / (finalColor + vec3f(1.0));
              let gamma = 2.2;
              finalColor = pow(finalColor, vec3f(1.0/gamma));

              return vec4f(finalColor, 1.0);
            }
          `;

          const shader = this.device.createShaderModule({
            label: "Material Viewer Shader",
            code: shaderCode
          });

          const bindGroupLayout = this.device.createBindGroupLayout({
            label: "Texture Bind Group Layout",
            entries: [
              { binding: 0, visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT, sampler: {} },
              { binding: 1, visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT, texture: {} },
              { binding: 2, visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT, texture: {} },
              { binding: 3, visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT, texture: {} },
              { binding: 4, visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT, texture: {} },
              { binding: 5, visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT, texture: {} },
              { binding: 6, visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT, texture: {} },
              { binding: 7, visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT, texture: {} },
              { binding: 8, visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT, texture: {} },
              { binding: 9, visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT, texture: {} },
              { binding: 10, visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT, buffer: { type: "uniform" } }
            ]
          });

          const pipelineLayout = this.device.createPipelineLayout({
            label: "Pipeline Layout",
            bindGroupLayouts: [bindGroupLayout],
          });

          const vertexBufferLayout = {
            arrayStride: 11 * 4,
            attributes: [
              { format: "float32x3", offset: 0, shaderLocation: 0 },
              { format: "float32x2", offset: 3 * 4, shaderLocation: 1 },
              { format: "float32x3", offset: 5 * 4, shaderLocation: 2 },
              { format: "float32x3", offset: 8 * 4, shaderLocation: 3 }
            ],
          };

          this.pipeline = this.device.createRenderPipeline({
            label: "Material Viewer Pipeline",
            layout: pipelineLayout,
            vertex: {
              module: shader,
              entryPoint: "vertexMain",
              buffers: [vertexBufferLayout],
            },
            fragment: {
              module: shader,
              entryPoint: "fragmentMain",
              targets: [{
                format: this.canvasFormat,
                blend: {
                  color: { srcFactor: "src-alpha", dstFactor: "one-minus-src-alpha", operation: "add" },
                  alpha: { srcFactor: "one", dstFactor: "one-minus-src-alpha", operation: "add" },
                },
              }],
            },
            primitive: { topology: "triangle-list", cullMode: "none" },
            depthStencil: { depthWriteEnabled: true, depthCompare: "less", format: "depth24plus" },
          });

          this.bindGroupLayout = bindGroupLayout;
        }

        updateDepthTexture() {
          if (this.depthTexture) {
            this.depthTexture.destroy();
          }
          this.depthTexture = this.device.createTexture({
            size: [this.canvas.width, this.canvas.height],
            format: "depth24plus",
            usage: GPUTextureUsage.RENDER_ATTACHMENT,
          });
        }

        async loadDefaultTextures() {
          this.showLoading(true);

          try {
            this.textures.baseColor = this.createEmptyTexture([128, 128, 128, 255]);
            this.textures.normal = this.createEmptyTexture([128, 128, 255, 255]);
            this.textures.roughness = this.createEmptyTexture([128, 128, 128, 255]);
            this.textures.metallic = this.createEmptyTexture([0, 0, 0, 255]);
            this.textures.ao = this.createEmptyTexture([255, 255, 255, 255]);
            this.textures.displacement = this.createEmptyTexture([128, 128, 128, 255]);
            this.textures.emissive = this.createEmptyTexture([0, 0, 0, 255]);
            this.textures.curvature = this.createEmptyTexture([128, 128, 128, 255]);
            this.textures.bump = this.createEmptyTexture([128, 128, 128, 255]);

            Object.keys(this.textureStatus).forEach(key => {
              this.textureStatus[key] = true;
            });

            this.updateBindGroup();
            this.updateTextureStatus();

            this.showLoading(false);
            this.showSuccess("Default textures loaded successfully!");
          } catch (error) {
            this.showLoading(false);
            this.showError("Error loading default textures: " + error.message);
          }
        }

        createEmptyTexture(color = [128, 128, 255, 255]) {
          const texture = this.device.createTexture({
            label: "Empty texture",
            size: [1, 1, 1],
            format: "rgba8unorm",
            usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,
          });

          const placeholderData = new Uint8Array(color);
          this.device.queue.writeTexture(
            { texture: texture },
            placeholderData,
            { bytesPerRow: 4 },
            [1, 1]
          );

          return texture;
        }

        updateBindGroup() {
          this.bindGroup = this.device.createBindGroup({
            label: "Texture Bind Group",
            layout: this.bindGroupLayout,
            entries: [
              { binding: 0, resource: this.sampler },
              { binding: 1, resource: this.textures.baseColor.createView() },
              { binding: 2, resource: this.textures.normal.createView() },
              { binding: 3, resource: this.textures.roughness.createView() },
              { binding: 4, resource: this.textures.metallic.createView() },
              { binding: 5, resource: this.textures.ao.createView() },
              { binding: 6, resource: this.textures.displacement.createView() },
              { binding: 7, resource: this.textures.emissive.createView() },
              { binding: 8, resource: this.textures.curvature.createView() },
              { binding: 9, resource: this.textures.bump.createView() },
              { binding: 10, resource: { buffer: this.uniformBuffer } }
            ]
          });
        }

        updateTextureStatus() {
          const statusElements = {
            baseColor: document.getElementById('baseColorStatus'),
            normal: document.getElementById('normalStatus'),
            roughness: document.getElementById('roughnessStatus'),
            metallic: document.getElementById('metallicStatus'),
            ao: document.getElementById('aoStatus'),
            displacement: document.getElementById('displacementStatus'),
            emissive: document.getElementById('emissiveStatus'),
            curvature: document.getElementById('curvatureStatus'),
            bump: document.getElementById('bumpStatus')
          };

          Object.keys(statusElements).forEach(key => {
            const element = statusElements[key];
            if (this.textureStatus[key]) {
              element.textContent = '‚úì';
              element.className = 'loaded';
            } else {
              element.textContent = '‚úó';
              element.className = 'missing';
            }
          });

          document.getElementById('currentMaterial').textContent = this.currentMaterialName;
        }

        createPlaneGeometry() {
          const vertices = new Float32Array([
            -1.0, -1.0, 0.0,  0.0, 1.0,  0.0, 0.0, 1.0,  1.0, 0.0, 0.0,
             1.0, -1.0, 0.0,  1.0, 1.0,  0.0, 0.0, 1.0,  1.0, 0.0, 0.0,
             1.0,  1.0, 0.0,  1.0, 0.0,  0.0, 0.0, 1.0,  1.0, 0.0, 0.0,
            -1.0,  1.0, 0.0,  0.0, 0.0,  0.0, 0.0, 1.0,  1.0, 0.0, 0.0,
          ]);

          const indices = new Uint16Array([0, 1, 2, 2, 3, 0]);
          return { vertices, indices, topology: "triangle-list" };
        }

        createCubeGeometry() {
          const s = 0.5;
          const vertices = new Float32Array([
            // Front face
            -s, -s,  s,  0.0, 1.0,  0.0, 0.0, 1.0,  1.0, 0.0, 0.0,
             s, -s,  s,  1.0, 1.0,  0.0, 0.0, 1.0,  1.0, 0.0, 0.0,
             s,  s,  s,  1.0, 0.0,  0.0, 0.0, 1.0,  1.0, 0.0, 0.0,
            -s,  s,  s,  0.0, 0.0,  0.0, 0.0, 1.0,  1.0, 0.0, 0.0,
            // Back face
            -s, -s, -s,  1.0, 1.0,  0.0, 0.0, -1.0, -1.0, 0.0, 0.0,
             s, -s, -s,  0.0, 1.0,  0.0, 0.0, -1.0, -1.0, 0.0, 0.0,
             s,  s, -s,  0.0, 0.0,  0.0, 0.0, -1.0, -1.0, 0.0, 0.0,
            -s,  s, -s,  1.0, 0.0,  0.0, 0.0, -1.0, -1.0, 0.0, 0.0,
            // Top face
            -s,  s, -s,  0.0, 1.0,  0.0, 1.0, 0.0,  1.0, 0.0, 0.0,
             s,  s, -s,  1.0, 1.0,  0.0, 1.0, 0.0,  1.0, 0.0, 0.0,
             s,  s,  s,  1.0, 0.0,  0.0, 1.0, 0.0,  1.0, 0.0, 0.0,
            -s,  s,  s,  0.0, 0.0,  0.0, 1.0, 0.0,  1.0, 0.0, 0.0,
            // Bottom face
            -s, -s, -s,  0.0, 0.0,  0.0, -1.0, 0.0, 1.0, 0.0, 0.0,
             s, -s, -s,  1.0, 0.0,  0.0, -1.0, 0.0, 1.0, 0.0, 0.0,
             s, -s,  s,  1.0, 1.0,  0.0, -1.0, 0.0, 1.0, 0.0, 0.0,
            -s, -s,  s,  0.0, 1.0,  0.0, -1.0, 0.0, 1.0, 0.0, 0.0,
            // Right face
             s, -s, -s,  0.0, 1.0,  1.0, 0.0, 0.0,  0.0, 0.0, -1.0,
             s,  s, -s,  0.0, 0.0,  1.0, 0.0, 0.0,  0.0, 0.0, -1.0,
             s,  s,  s,  1.0, 0.0,  1.0, 0.0, 0.0,  0.0, 0.0, -1.0,
             s, -s,  s,  1.0, 1.0,  1.0, 0.0, 0.0,  0.0, 0.0, -1.0,
            // Left face
            -s, -s, -s,  1.0, 1.0,  -1.0, 0.0, 0.0, 0.0, 0.0, 1.0,
            -s,  s, -s,  1.0, 0.0,  -1.0, 0.0, 0.0, 0.0, 0.0, 1.0,
            -s,  s,  s,  0.0, 0.0,  -1.0, 0.0, 0.0, 0.0, 0.0, 1.0,
            -s, -s,  s,  0.0, 1.0,  -1.0, 0.0, 0.0, 0.0, 0.0, 1.0,
          ]);

          const indices = new Uint16Array([
            0, 1, 2,  2, 3, 0,    // Front
            4, 5, 6,  6, 7, 4,    // Back
            8, 9, 10, 10, 11, 8,  // Top
            12, 13, 14, 14, 15, 12, // Bottom
            16, 17, 18, 18, 19, 16, // Right
            20, 21, 22, 22, 23, 20  // Left
          ]);

          return { vertices, indices, topology: "triangle-list" };
        }

        createSphereGeometry() {
          const radius = 0.7;
          const latitudeBands = 32;
          const longitudeBands = 32;

          const positions = [];
          const texCoords = [];
          const normals = [];
          const tangents = [];
          const indices = [];

          for (let lat = 0; lat <= latitudeBands; lat++) {
            const theta = lat * Math.PI / latitudeBands;
            const sinTheta = Math.sin(theta);
            const cosTheta = Math.cos(theta);

            for (let lon = 0; lon <= longitudeBands; lon++) {
              const phi = lon * 2 * Math.PI / longitudeBands;
              const sinPhi = Math.sin(phi);
              const cosPhi = Math.cos(phi);

              const x = cosPhi * sinTheta;
              const y = cosTheta;
              const z = sinPhi * sinTheta;
              positions.push(radius * x, radius * y, radius * z);

              texCoords.push(1 - (lon / longitudeBands), 1 - (lat / latitudeBands));
              normals.push(x, y, z);

              const tx = -sinPhi;
              const ty = 0;
              const tz = cosPhi;
              const tangentLength = Math.sqrt(tx*tx + ty*ty + tz*tz);
              tangents.push(tx/tangentLength, ty/tangentLength, tz/tangentLength);
            }
          }

          for (let lat = 0; lat < latitudeBands; lat++) {
            for (let lon = 0; lon < longitudeBands; lon++) {
              const first = (lat * (longitudeBands + 1)) + lon;
              const second = first + longitudeBands + 1;

              indices.push(first, second, first + 1);
              indices.push(second, second + 1, first + 1);
            }
          }

          const interleavedVertices = new Float32Array(positions.length + texCoords.length + normals.length + tangents.length);
          let vertexIndex = 0;

          for (let i = 0; i < positions.length / 3; i++) {
            interleavedVertices[vertexIndex++] = positions[i * 3];
            interleavedVertices[vertexIndex++] = positions[i * 3 + 1];
            interleavedVertices[vertexIndex++] = positions[i * 3 + 2];
            interleavedVertices[vertexIndex++] = texCoords[i * 2];
            interleavedVertices[vertexIndex++] = texCoords[i * 2 + 1];
            interleavedVertices[vertexIndex++] = normals[i * 3];
            interleavedVertices[vertexIndex++] = normals[i * 3 + 1];
            interleavedVertices[vertexIndex++] = normals[i * 3 + 2];
            interleavedVertices[vertexIndex++] = tangents[i * 3];
            interleavedVertices[vertexIndex++] = tangents[i * 3 + 1];
            interleavedVertices[vertexIndex++] = tangents[i * 3 + 2];
          }

          return { vertices: interleavedVertices, indices: new Uint16Array(indices), topology: "triangle-list" };
        }

        createCylinderGeometry() {
          return this.createCubeGeometry();
        }

        createTeapotGeometry() {
          return this.createSphereGeometry();
        }

        getModelGeometry() {
          switch (this.state.model) {
            case "cube": return this.createCubeGeometry();
            case "sphere": return this.createSphereGeometry();
            case "cylinder": return this.createCylinderGeometry();
            case "teapot": return this.createTeapotGeometry();
            default: return this.createPlaneGeometry();
          }
        }

        updateGeometry() {
          this.currentGeometry = this.getModelGeometry();

          if (this.vertexBuffer) this.vertexBuffer.destroy();
          if (this.indexBuffer) this.indexBuffer.destroy();

          this.vertexBuffer = this.device.createBuffer({
            label: "Model vertices",
            size: this.currentGeometry.vertices.byteLength,
            usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
          });
          this.device.queue.writeBuffer(this.vertexBuffer, 0, this.currentGeometry.vertices);

          this.indexBuffer = this.device.createBuffer({
            label: "Model indices",
            size: this.currentGeometry.indices.byteLength,
            usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST,
          });
          this.device.queue.writeBuffer(this.indexBuffer, 0, this.currentGeometry.indices);
        }

        createModelMatrix() {
          const rotateX = [
            1, 0, 0, 0,
            0, Math.cos(this.state.rotation.x), Math.sin(this.state.rotation.x), 0,
            0, -Math.sin(this.state.rotation.x), Math.cos(this.state.rotation.x), 0,
            0, 0, 0, 1
          ];

          const rotateY = [
            Math.cos(this.state.rotation.y), 0, -Math.sin(this.state.rotation.y), 0,
            0, 1, 0, 0,
            Math.sin(this.state.rotation.y), 0, Math.cos(this.state.rotation.y), 0,
            0, 0, 0, 1
          ];

          const result = new Float32Array(16);
          for (let i = 0; i < 4; i++) {
            for (let j = 0; j < 4; j++) {
              result[i * 4 + j] = 0;
              for (let k = 0; k < 4; k++) {
                result[i * 4 + j] += rotateX[i * 4 + k] * rotateY[k * 4 + j];
              }
            }
          }
          return result;
        }

        createViewMatrix() {
          return new Float32Array([
            1, 0, 0, 0,
            0, 1, 0, 0,
            0, 0, 1, 0,
            0, 0, -this.state.zoomLevel, 1
          ]);
        }

        createProjectionMatrix() {
          const fov = 45 * Math.PI / 180;
          const aspect = this.canvas.width / this.canvas.height;
          const near = 0.1;
          const far = 100.0;
          const f = 1.0 / Math.tan(fov / 2);

          return new Float32Array([
            f / aspect, 0, 0, 0,
            0, f, 0, 0,
            0, 0, (far + near) / (near - far), -1,
            0, 0, (2 * far * near) / (near - far), 0
          ]);
        }

        async loadTextureFolder(files) {
          this.showLoading(true);
          this.showStatus("Loading new material...", "info");

          try {
            if (files.length > 0) {
              const firstName = files[0].name;
              const baseName = this.extractBaseName(firstName);
              this.currentMaterialName = baseName || "Custom Material";
            }

            Object.keys(this.textureStatus).forEach(key => {
              this.textureStatus[key] = false;
            });

            const textureMap = this.mapFilesToTextureTypes(files);

            const loadPromises = Object.entries(textureMap).map(async ([type, file]) => {
              if (file) {
                try {
                  const texture = await this.loadTextureFromFile(file, type);
                  this.textures[type] = texture;
                  this.textureStatus[type] = true;
                } catch (error) {
                  console.error(`Failed to load ${type} texture:`, error);
                  this.textures[type] = this.createEmptyTexture([255, 0, 255, 255]);
                  this.textureStatus[type] = false;
                }
              } else {
                const defaultColors = {
                  baseColor: [128, 128, 128, 255],
                  normal: [128, 128, 255, 255],
                  roughness: [128, 128, 128, 255],
                  metallic: [0, 0, 0, 255],
                  ao: [255, 255, 255, 255],
                  displacement: [128, 128, 128, 255],
                  emissive: [0, 0, 0, 255],
                  curvature: [128, 128, 128, 255],
                  bump: [128, 128, 128, 255]
                };
                this.textures[type] = this.createEmptyTexture(defaultColors[type]);
                this.textureStatus[type] = false;
              }
            });

            await Promise.all(loadPromises);

            this.updateBindGroup();
            this.updateTextureStatus();

            this.showLoading(false);
            this.showSuccess(`Successfully loaded material: ${this.currentMaterialName}`);

          } catch (error) {
            this.showLoading(false);
            this.showError("Error loading material: " + error.message);
          }
        }

        extractBaseName(filename) {
          const nameWithoutExt = filename.replace(/\.[^/.]+$/, "");

          const patterns = [
            /_BaseColor$/i, /_Albedo$/i, /_Diffuse$/i,
            /_Normal$/i,
            /_Roughness$/i,
            /_Metallic$/i, /_Metalness$/i,
            /_AO$/i, /_Occlusion$/i,
            /_Displacement$/i, /_Height$/i,
            /_Emissive$/i, /_Emission$/i,
            /_Curvature$/i, /_Cavity$/i,
            /_Bump$/i
          ];

          let baseName = nameWithoutExt;
          for (const pattern of patterns) {
            if (pattern.test(baseName)) {
              baseName = baseName.replace(pattern, "");
            }
          }

          return baseName;
        }

        mapFilesToTextureTypes(files) {
          const textureMap = {
            baseColor: null, normal: null, roughness: null, metallic: null,
            ao: null, displacement: null, emissive: null, curvature: null, bump: null
          };

          for (const file of files) {
            const filename = file.name.toLowerCase();

            if (filename.includes('basecolor') || filename.includes('albedo') || filename.includes('diffuse')) {
              textureMap.baseColor = file;
            } else if (filename.includes('normal')) {
              textureMap.normal = file;
            } else if (filename.includes('roughness')) {
              textureMap.roughness = file;
            } else if (filename.includes('metallic') || filename.includes('metalness')) {
              textureMap.metallic = file;
            } else if (filename.includes('ao') || filename.includes('occlusion')) {
              textureMap.ao = file;
            } else if (filename.includes('displacement') || filename.includes('height')) {
              if (!textureMap.displacement) {
                textureMap.displacement = file;
              }
            } else if (filename.includes('emissive') || filename.includes('emission')) {
              textureMap.emissive = file;
            } else if (filename.includes('curvature') || filename.includes('cavity')) {
              textureMap.curvature = file;
            } else if (filename.includes('bump')) {
              textureMap.bump = file;
            }
          }

          return textureMap;
        }

        async loadTextureFromFile(file, type) {
          return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = async (e) => {
              const img = new Image();
              img.onload = async () => {
                try {
                  const imageBitmap = await createImageBitmap(img);

                  const texture = this.device.createTexture({
                    label: `${type}: ${file.name}`,
                    size: [imageBitmap.width, imageBitmap.height, 1],
                    format: "rgba8unorm",
                    usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT,
                  });

                  this.device.queue.copyExternalImageToTexture(
                    { source: imageBitmap },
                    { texture: texture },
                    [imageBitmap.width, imageBitmap.height]
                  );

                  resolve(texture);
                } catch (error) {
                  reject(error);
                }
              };
              img.onerror = () => reject(new Error(`Failed to load image: ${file.name}`));
              img.src = e.target.result;
            };
            reader.onerror = () => reject(new Error(`Failed to read file: ${file.name}`));
            reader.readAsDataURL(file);
          });
        }

        showLoading(show) {
          const indicator = document.getElementById('loadingIndicator');
          indicator.classList.toggle('active', show);
        }

        showStatus(message, type) {
          const statusEl = document.getElementById('statusMessage');
          statusEl.textContent = message;
          statusEl.className = `status-message ${type}`;
          statusEl.style.display = 'block';

          setTimeout(() => {
            statusEl.style.display = 'none';
          }, 5000);
        }

        showSuccess(message) {
          this.showStatus(message, 'success');
        }

        showError(message) {
          this.showStatus(message, 'error');
        }

        setupEventListeners() {
          // Mouse interaction
          this.canvas.addEventListener("mousedown", (e) => {
            this.state.dragState.dragging = true;
            this.state.dragState.lastX = e.clientX;
            this.state.dragState.lastY = e.clientY;
          });

          this.canvas.addEventListener("mouseup", () => {
            this.state.dragState.dragging = false;
          });

          this.canvas.addEventListener("mousemove", (e) => {
            if (this.state.dragState.dragging) {
              const deltaX = e.clientX - this.state.dragState.lastX;
              const deltaY = e.clientY - this.state.dragState.lastY;

              this.state.rotation.y += deltaX * 0.01;
              this.state.rotation.x += deltaY * 0.01;

              this.state.dragState.lastX = e.clientX;
              this.state.dragState.lastY = e.clientY;
            }
          });

          // Mouse wheel for zoom
          this.canvas.addEventListener("wheel", (e) => {
            e.preventDefault();
            const zoomSpeed = 0.2;
            if (e.deltaY < 0) {
              this.state.zoomLevel = Math.max(0.5, this.state.zoomLevel - zoomSpeed);
            } else {
              this.state.zoomLevel = Math.min(15.0, this.state.zoomLevel + zoomSpeed);
            }
            document.getElementById('zoomLevel').value = this.state.zoomLevel;
            document.getElementById('zoomLevelValue').textContent = this.state.zoomLevel.toFixed(1);
          });

          // File loading
          document.getElementById("textureFolder").addEventListener("change", (e) => {
            if (e.target.files.length > 0) {
              this.loadTextureFolder(Array.from(e.target.files));
            }
          });

          document.getElementById("individualTextures").addEventListener("change", (e) => {
            if (e.target.files.length > 0) {
              this.loadTextureFolder(Array.from(e.target.files));
            }
          });

          // Mode switching
          document.getElementById("mode2D").addEventListener("click", () => {
            this.state.mode = "2D";
            document.getElementById("mode2D").classList.add("active");
            document.getElementById("mode3D").classList.remove("active");
          });

          document.getElementById("mode3D").addEventListener("click", () => {
            this.state.mode = "3D";
            document.getElementById("mode3D").classList.add("active");
            document.getElementById("mode2D").classList.remove("active");
          });

          // Model and shading selection
          document.getElementById("modelSelect").addEventListener("change", (e) => {
            this.state.model = e.target.value;
            this.updateGeometry();
          });

          document.getElementById("shadingModel").addEventListener("change", (e) => {
            this.state.shadingModel = e.target.value;
          });

          // Range controls
          this.setupRangeControl("lightPosX", "lightPosXValue", (val) => this.state.lightPos.x = val);
          this.setupRangeControl("lightPosY", "lightPosYValue", (val) => this.state.lightPos.y = val);
          this.setupRangeControl("lightPosZ", "lightPosZValue", (val) => this.state.lightPos.z = val);
          this.setupRangeControl("lightIntensity", "lightIntensityValue", (val) => this.state.lightIntensity = val);
          this.setupRangeControl("displacementScale", "displacementScaleValue", (val) => this.state.displacementScale = val, 3);
          this.setupRangeControl("normalMapIntensity", "normalMapIntensityValue", (val) => this.state.normalMapIntensity = val, 2);
          this.setupRangeControl("curvatureIntensity", "curvatureIntensityValue", (val) => this.state.curvatureIntensity = val, 2);
          this.setupRangeControl("bumpIntensity", "bumpIntensityValue", (val) => this.state.bumpIntensity = val, 2);
          this.setupRangeControl("zoomLevel", "zoomLevelValue", (val) => this.state.zoomLevel = val, 1);

          // Checkboxes
          this.setupCheckbox("baseColorMapping", (checked) => this.state.maps.baseColor = checked);
          this.setupCheckbox("normalMapping", (checked) => this.state.maps.normal = checked);
          this.setupCheckbox("roughnessMapping", (checked) => this.state.maps.roughness = checked);
          this.setupCheckbox("metallicMapping", (checked) => this.state.maps.metallic = checked);
          this.setupCheckbox("aoMapping", (checked) => this.state.maps.ao = checked);
          this.setupCheckbox("displacementMapping", (checked) => this.state.maps.displacement = checked);
          this.setupCheckbox("emissiveMapping", (checked) => this.state.maps.emissive = checked);
          this.setupCheckbox("curvatureMapping", (checked) => this.state.maps.curvature = checked);
          this.setupCheckbox("bumpMapping", (checked) => this.state.maps.bump = checked);
          this.setupCheckbox("enableDirectionalLight", (checked) => this.state.enableDirectionalLight = checked);
          this.setupCheckbox("enablePointLight", (checked) => this.state.enablePointLight = checked);

          // Buttons
          document.getElementById("toggleAutoRotate").addEventListener("click", (e) => {
            this.state.autoRotate = !this.state.autoRotate;
            e.target.textContent = this.state.autoRotate ? "Stop Rotation" : "Start Rotation";
          });

          document.getElementById("resetView").addEventListener("click", () => {
            this.state.rotation = { x: 0, y: 0 };
            this.state.zoomLevel = 3.0;
            document.getElementById('zoomLevel').value = this.state.zoomLevel;
            document.getElementById('zoomLevelValue').textContent = this.state.zoomLevel.toFixed(1);
          });

          // Zoom buttons
          document.getElementById("zoomIn").addEventListener("click", () => {
            this.state.zoomLevel = Math.max(0.5, this.state.zoomLevel - 0.5);
            document.getElementById('zoomLevel').value = this.state.zoomLevel;
            document.getElementById('zoomLevelValue').textContent = this.state.zoomLevel.toFixed(1);
          });

          document.getElementById("zoomOut").addEventListener("click", () => {
            this.state.zoomLevel = Math.min(15.0, this.state.zoomLevel + 0.5);
            document.getElementById('zoomLevel').value = this.state.zoomLevel;
            document.getElementById('zoomLevelValue').textContent = this.state.zoomLevel.toFixed(1);
          });

          // Export functionality
          document.getElementById("downloadPNG").addEventListener("click", () => this.downloadCanvasAsImage("png"));
          document.getElementById("downloadJPG").addEventListener("click", () => this.downloadCanvasAsImage("jpg"));
          document.getElementById("downloadTIFF").addEventListener("click", () => this.downloadCanvasAsImage("tiff"));
          document.getElementById("downloadAllMaps").addEventListener("click", () => {
            this.showStatus("Export all maps feature would be implemented in production.", "info");
          });
        }

        setupRangeControl(inputId, displayId, callback, decimals = 1) {
          const input = document.getElementById(inputId);
          const display = document.getElementById(displayId);

          const initialValue = parseFloat(input.value);
          display.textContent = initialValue.toFixed(decimals);

          input.addEventListener("input", (e) => {
            const value = parseFloat(e.target.value);
            callback(value);
            display.textContent = value.toFixed(decimals);
          });
        }

        setupCheckbox(inputId, callback) {
          document.getElementById(inputId).addEventListener("change", (e) => {
            callback(e.target.checked);
          });
        }

        downloadCanvasAsImage(format) {
          const link = document.createElement('a');
          const mimeType = format === 'jpg' ? 'image/jpeg' : 
                          format === 'tiff' ? 'image/tiff' : 'image/png';

          const actualFormat = format === 'tiff' ? 'png' : format;

          link.download = `material-preview.${actualFormat}`;
          link.href = this.canvas.toDataURL(mimeType, format === 'jpg' ? 0.9 : 1.0);
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
        }

        render() {
          const currentTime = performance.now();
          const deltaTime = (currentTime - this.lastTime) * 0.001;
          const time = (currentTime - this.startTime) * 0.001;
          this.lastTime = currentTime;

          if (this.state.autoRotate && this.state.mode === "3D") {
            this.state.rotation.y += deltaTime * 0.5;
          }

          const modelMatrix = this.createModelMatrix();
          const viewMatrix = this.createViewMatrix();
          const projMatrix = this.createProjectionMatrix();
          const normalMatrix = new Float32Array([
            modelMatrix[0], modelMatrix[1], modelMatrix[2], 0,
            modelMatrix[4], modelMatrix[5], modelMatrix[6], 0,
            modelMatrix[8], modelMatrix[9], modelMatrix[10], 0,
            0, 0, 0, 1
          ]);

          const uniformArray = new Float32Array(120);
          let offset = 0;

          // Matrices
          for (let i = 0; i < 16; i++) uniformArray[offset++] = viewMatrix[i];
          for (let i = 0; i < 16; i++) uniformArray[offset++] = projMatrix[i];
          for (let i = 0; i < 16; i++) uniformArray[offset++] = modelMatrix[i];
          for (let i = 0; i < 16; i++) uniformArray[offset++] = normalMatrix[i];

          // Vectors
          uniformArray[offset++] = 0; uniformArray[offset++] = 0; 
          uniformArray[offset++] = this.state.zoomLevel; uniformArray[offset++] = 1; // viewPos
          uniformArray[offset++] = this.state.lightPos.x; uniformArray[offset++] = this.state.lightPos.y;
          uniformArray[offset++] = this.state.lightPos.z; uniformArray[offset++] = 1; // lightPos
          uniformArray[offset++] = 1; uniformArray[offset++] = 1; uniformArray[offset++] = 1;
          uniformArray[offset++] = this.state.lightIntensity; // lightColor

          // Map flags
          uniformArray[offset++] = this.state.maps.baseColor ? 1.0 : 0.0;
          uniformArray[offset++] = this.state.maps.normal ? 1.0 : 0.0;
          uniformArray[offset++] = this.state.maps.roughness ? 1.0 : 0.0;
          uniformArray[offset++] = this.state.maps.metallic ? 1.0 : 0.0;
          uniformArray[offset++] = this.state.maps.ao ? 1.0 : 0.0;
          uniformArray[offset++] = this.state.maps.displacement ? 1.0 : 0.0;
          uniformArray[offset++] = this.state.maps.emissive ? 1.0 : 0.0;
          uniformArray[offset++] = this.state.maps.curvature ? 1.0 : 0.0;
          uniformArray[offset++] = this.state.maps.bump ? 1.0 : 0.0;

          // Parameters
          uniformArray[offset++] = this.state.mode === "2D" ? 0.0 : 1.0;
          uniformArray[offset++] = this.state.normalMapIntensity;
          uniformArray[offset++] = this.state.curvatureIntensity;
          uniformArray[offset++] = this.state.bumpIntensity;
          uniformArray[offset++] = this.state.displacementScale;
          uniformArray[offset++] = this.state.shadingModel === "ggx" ? 1.0 : 0.0;
          uniformArray[offset++] = this.state.enableDirectionalLight ? 1.0 : 0.0;
          uniformArray[offset++] = this.state.enablePointLight ? 1.0 : 0.0;
          uniformArray[offset++] = time;

          this.device.queue.writeBuffer(this.uniformBuffer, 0, uniformArray);

          const encoder = this.device.createCommandEncoder();
          const pass = encoder.beginRenderPass({
            colorAttachments: [{
              view: this.context.getCurrentTexture().createView(),
              loadOp: "clear",
              clearValue: { r: 0.1, g: 0.1, b: 0.1, a: 1.0 },
              storeOp: "store",
            }],
            depthStencilAttachment: {
              view: this.depthTexture.createView(),
              depthClearValue: 1.0,
              depthLoadOp: "clear",
              depthStoreOp: "store",
            }
          });

          pass.setPipeline(this.pipeline);
          pass.setBindGroup(0, this.bindGroup);
          pass.setVertexBuffer(0, this.vertexBuffer);
          pass.setIndexBuffer(this.indexBuffer, "uint16");
          pass.drawIndexed(this.currentGeometry.indices.length);
          pass.end();

          this.device.queue.submit([encoder.finish()]);
          requestAnimationFrame(() => this.render());
        }
      }

      const viewer = new MaterialViewer();
      viewer.init().catch(console.error);
    </script>
  </body>
</html>
